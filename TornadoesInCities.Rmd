---
title: "Tornadoes in Cities"
output: html_document
editor_options: 
  chunk_output_type: console
---

What cities (core-based statistical areas--cbsa) have seen the biggest change in tornado frequency before/after 1985? Here I divide the tornado record into two epochs: 1985-2019 and 1950-1984 and count the number of tornadoes within each core-based statistical area during each epoch.

Load packages.
```{r}
library(sf)
library(tidyverse)
library(tidycensus)
library(tigris)
```

Get USA boundary map from {tidycensus}.
```{r}
data(state_laea)

state_laea <- state_laea |>
  st_transform(crs = 32615) 
plot(state_laea)
```

The Core-Based Statistical Areas (CBSA) are geographic locations neighboring urban areas of 10,000+ population and/or are socioeconomically tied to the urban center by commute proximity. Prior to the year 2000, these were collectively known as MSA- Metropolitan Statistical Areas and Micropolitan Statistical Areas. An exclusive feature of GreatData CBSA Data is that the population statistics are calculated annually. Therefore, the CBSA rank is based on a more recent population than typical census data classifications.

https://catalog.data.gov/dataset/tiger-line-shapefile-2019-nation-u-s-current-metropolitan-statistical-area-micropolitan-statist https://www2.census.gov/geo/tiger/TIGER2019/CBSA/tl_2019_us_cbsa.zip

Get the CBSA polygons.
```{r}
if(!"tl_2019_us_cbsa" %in% list.files()){
unzip("tl_2019_us_cbsa.zip",
      exdir = "tl_2019_us_cbsa")
}

CBSA.sf <- read_sf(dsn = "tl_2019_us_cbsa", 
                   layer = "tl_2019_us_cbsa") |>
  st_transform(crs = st_crs(state_laea)) 

#  mutate(GEOID_ST = substr(GEOID, start = 1, stop = 2)) |>
#  filter(GEOID_ST %in% state_laea$GEOID)
```

Same from the {tigris} package.
```{r}
CBSA2.sf <- core_based_statistical_areas()
```

Get the tornado tracks. Tracks that recorded at least EF2 damage somewhere.
```{r}
if(!"1950-2019-torn-aspath" %in% list.files()) {
download.file(url = "http://www.spc.noaa.gov/gis/svrgis/zipped/1950-2019-torn-aspath.zip",
              destfile = "1950-2019-torn-aspath.zip")
unzip("1950-2019-torn-aspath.zip")
}

Torn.sf <- st_read(dsn = "1950-2019-torn-aspath", 
                   layer = "1950-2019-torn-aspath") |>
  st_transform(crs = st_crs(state_laea)) |>
  mutate(Late = yr >= 1985) |>
  filter(mag >= 2)
```

Create a map showing one CBSA and the intersecting tornado tracks. Colors from https://image-color-picker.com/hex-code-picker
```{r}
NameC <- "Atlanta-Sandy Springs-Alpharetta, GA"
Area.sf <- CBSA.sf |>
  filter(NAME == NameC)

State.sf <- state_laea |>
  filter(GEOID == "13")

Intersects <- Area.sf |>
  st_intersects(Torn.sf) |>
  unlist()

AreaTors.sf <- Torn.sf[Intersects, ]

nT <- AreaTors.sf |>
  group_by(Late) |>
  summarize(nT = n()) |>
  pull(nT)

ggplot() +
  geom_sf(data = State.sf, fill = "white") +
  geom_sf(data = Area.sf, color = "gray70") +
  geom_sf(data = AreaTors.sf, 
          mapping = aes(color = Late)) +
  scale_color_manual(values = c("#9E1FDE", "#5FDE1F"),
                     guide = "none") +
  labs(title = paste0("Approximate tracks of significant tornadoes\n", NameC),
       subtitle = paste0("Total numbers: 1950-1984 (purple): ", nT[1], 
                         paste0(", 1985-2019 (green): ", nT[2])))
```

All metro areas. Also see {stars.Rmd} for creating a space-time object.
```{r}
Intersects <- CBSA.sf |>
  st_intersects(Torn.sf) |>
  unlist()
AreaTors.sf <- Torn.sf[Intersects, ]

Intersects.m <- CBSA.sf |>
  st_intersects(Torn.sf, sparse = FALSE)

TorCounts.sf <- 
  data.frame(GEOID = CBSA.sf$GEOID, 
             NAME = CBSA.sf$NAME,
             nT = rowSums(Intersects.m),
             geometry = CBSA.sf$geometry) |>
  st_as_sf()
```

```{r}
TorCounts.sf |>
  arrange(desc(nT))

TorCounts.sf |>
  slice_max(nT, n = 25) |>
  ggplot(mapping = aes(y = reorder(NAME, nT), x = nT)) +
  geom_point(size = 2, colour = "black") + 
  geom_segment(mapping = aes(yend = NAME, xend = 0), size = 1)+
  labs(y = "", x = "") +
  theme_minimal()
```

```{r}
library(patchwork)

Top25.sf <- TorCounts.sf |>
  slice_max(nT, n = 25)

( US_map <- ggplot(data = state_laea) +
  geom_sf(fill = 'gray90', color = 'white', size = .15) +
  geom_sf(data = Top25.sf, size = 0,
          mapping = aes(fill = nT)) + 
  scale_fill_distiller(palette = "Oranges",
                       direction = 1, 
                       guide = 'none') + 
  theme_void() 
)

( P_plot <- ggplot(data = Top25.sf, 
                   mapping = aes(x = nT, y = reorder(NAME, nT), color = nT)) +
  geom_point(size = 2) +
  scale_color_distiller(palette = "Oranges",
                        direction = 1, 
                        guide = 'none') + 
  scale_x_continuous(limits = c(0, NA)) +
  labs(title = "Top 25 Metropolitan Areas by Number of Significant Tornadoes",
       subtitle = "1950-2019",
       y = "", x = "") + 
  theme_minimal() +
    theme(axis.ticks = element_blank(),
          panel.grid  = element_blank()) )

P_plot / US_map
```

Create a link/hover with map. https://twitter.com/kyle_e_walker/status/1397530708218892293 https://gist.github.com/walkerke/3628171efae66421c299c9f2dbee0f34

```{r}
library(ggiraph)

( US_map <- ggplot(data = state_laea) +
  geom_sf(fill = 'gray90', color = 'white', size = .15) +
  geom_sf_interactive(data = Top25.sf, size = 0,
                      mapping = aes(fill = nT, color = nT, data_id = GEOID)) + 
  scale_fill_distiller(palette = "Oranges",
                       direction = 1, 
                       guide = 'none') + 
  scale_color_distiller(palette = "Oranges",
                       direction = 1, 
                       guide = 'none') + 
  theme_void() )

( P_plot <- ggplot(data = Top25.sf, 
                   mapping = aes(x = nT, y = reorder(NAME, nT), color = nT)) +
  geom_point_interactive(size = 2, mapping = aes(data_id = GEOID)) +
  scale_color_distiller(palette = "Oranges",
                        direction = 1, 
                        guide = 'none') +
  scale_x_continuous(limits = c(0, NA)) +
  labs(title = "Top 25 Metropolitan Areas by\n Number of Significant Tornadoes",
       subtitle = "1950-2019",
       y = "", x = "") + 
    theme_minimal() +
    theme(axis.ticks = element_blank(),
          panel.grid  = element_blank())  )

girafe(ggobj = P_plot / US_map, width_svg = 8, height_svg = 6) |>
  girafe_options(opts_hover(css = "fill:cyan;stroke:cyan;"))
```

Counts grouped early and late
```{r}
Intersects <- CBSA.sf |>
  st_intersects(Torn.sf) |>
  unlist()
AreaTors.sf <- Torn.sf[Intersects, ]

AreaTors.sf$GEOID <- rep(CBSA.sf$GEOID, 
                         times = rowSums(Intersects.m))

TorCounts.df <- AreaTors.sf |>
  st_drop_geometry() |>
  group_by(GEOID, Late) |>
  summarize(nT = n()) |>
  ungroup()

( Diff.df <- TorCounts.df |>
  pivot_wider(names_from = Late, 
              values_from = nT) |>
  rename(After1985 = `TRUE`,
         Before1985 = `FALSE`) |>
  mutate(Difference = After1985 - Before1985,
         DiffPerc = Difference/Before1985 * 100) |>
  drop_na() )

sum(Diff.df$Difference > 0)
sum(Diff.df$Difference < 0)
```

Map of changes across all CBSAs group by +/- and 0.
```{r}
Diff.df <-
  Diff.df |>
   mutate(Change = case_when(Difference == 0 ~ 'No change',
                             Difference < 0 ~ 'Fewer since 1985',
                             Difference > 0 ~ 'More since 1985'))

All.sf <- CBSA.sf |>
  right_join(Diff.df,
             by = "GEOID") 

( US_map <- ggplot(data = state_laea) +
  geom_sf(fill = 'gray90',color = 'white', size = .15) +
  geom_sf(data = All.sf, size = 0,
          mapping = aes(fill = Change)) + 
  scale_fill_manual(values = c("#84E119", "#E11984", "#1984E1")) +
  labs(title = "                     The shifting U.S. tornado threat (EF2 or worse damage)",
       caption = "    Gray regions are outside of core-based statistical areas or there were no EF2+ tornadoes either before or after 1985 in record from 1950-2019.") +
  theme_void() +
  theme(legend.title=element_blank()) )
```

Top 10 and bottom 10 combined.
```{r}
Upward <- Diff.df |>
  slice_max(Difference, n = 100) |>
  mutate(Tendency = "Upward")

Downward <- Diff.df |>
  slice_min(Difference, n = 100) |>
  mutate(Tendency = "Downward")

Both <- rbind(Upward, Downward)

Both <- Both |>
  left_join(CBSA.sf,
            by = "GEOID") 
```

Plot a slope graph.
```{r}
library(ggrepel)

ggplot(Both) +
  geom_segment(mapping = aes(x = .4, xend = .6, 
                             y = Before1985, yend = After1985, 
                             color = Tendency)) +
  scale_color_manual(values = c("#E69F00", "#CC79A7"), guide = 'none') +
  scale_x_continuous(limits = c(0, 1)) +
  theme(panel.background = element_blank(),
        panel.grid=element_blank(),
        axis.ticks=element_blank(),
        axis.text=element_blank(),
        panel.border=element_blank()) +
  geom_text(data = Both[Both$Tendency == "Upward", ],
            mapping = aes(x = .62, y = After1985, 
                          label = paste(After1985, NAME, sep = "   ")), hjust = 0, size = 3.5, color = "#CC79A7") +
  geom_text(data = Both[Both$Tendency == "Downward", ], 
            mapping = aes(x = .38, y = Before1985, 
                          label = paste(NAME, Before1985, sep = "   ")), hjust = 1, size = 3.5, color = "#E69F00") +
  geom_text(data = Both[1, ], 
            mapping = aes(label = "1950-1984", x = .38, y = 1), hjust = 1, size = 4) +
  geom_text(data = Both[1, ], 
            mapping = aes(label = "1985-2018", x = .62, y = 1), hjust = 0, size = 4) +
  geom_segment(data = Both[1,],
               mapping = aes(x = .45, y = 1, xend = .55, yend = 1), color = "gray70",
               arrow = arrow(angle = 20, length = unit(2, "mm"), type = "closed")) +
  labs(title = "The shifting tornado threat",
       subtitle = "Cities with the largest change in number of significant tornadoes (EF2 or worse damage)",
       x = "", y = "")
```

Create a link/hover with map. https://twitter.com/kyle_e_walker/status/1397530708218892293 https://gist.github.com/walkerke/3628171efae66421c299c9f2dbee0f34

```{r}
Both <- Both |>
  select(GEOID, After1985, Before1985, Difference)

Both.sf <- CBSA.sf |>
  right_join(Both,
            by = "GEOID") 

( US_map <- ggplot(data = state_laea) +
  geom_sf(fill = 'gray90',color = 'white', size = .15) +
  geom_sf(data = Both.sf, size = 0,
          mapping = aes(fill = Difference > 0)) + 
  scale_fill_manual(values = c("#E69F00", "#CC79A7"),
                    guide = 'none') +
  theme_void() )

( P_plot <- ggplot(data = Both.sf, 
                   mapping = aes(x = Difference, y = reorder(NAME, Difference), 
                                 color = Difference > 0)) +
  geom_point(size = 2.5) +
  geom_vline(xintercept = 0, color = "gray80") +
  scale_color_manual(values = c("#E69F00", "#CC79A7"),
                      guide = 'none') +
  scale_x_continuous(limits = c(-65, 65), position = "top") +
  labs(title = "Top changes in significant tornado counts in CBSAs since 1985",
       y = "", x = "Fewer tornadoes      More Tornadoes") + 
  theme_minimal() +
  theme(axis.title.x = element_text(margin = margin(t = 2, unit = "cm")), 
        axis.ticks = element_blank(),
        panel.grid  = element_blank(),
        axis.line.x = element_line(arrow = grid::arrow(length = unit(2, "mm"), 
                                                       angle = 20, 
                                                       type = "closed", 
                                                       ends = "both"))) )

P_plot / US_map
```

## How much more likely is a tornado that occurs away from an urban area to get a lower EF rating?
```{r}
Plains <- c("TX", "OK", "KS", "NE", "SD", "ND")
Area.sfc <- states() |>
  filter(STUSPS %in% Plains) |>
  st_union()

Urban2020.sf <- urban_areas(year = 2020) |>
#   st_intersection(Area.sfc)
  st_crop(Area.sfc) # crops to the bounding box, not the area polygon

#KS_Urban2012.sf <- urban_areas(year = 2012) |>
#  st_crop(KS.sf)
```

Map check
```{r}
library(tmap)
tmap_mode("view")

tm_shape(Area.sf) +
  tm_borders() +
  tm_shape(Urban2020.sf) +
  tm_borders() 
```

Get the tornado tracks since 2007 (start of EF rating).
```{r}
Torn.sf <- st_read(dsn = "1950-2019-torn-aspath", 
                   layer = "1950-2019-torn-aspath") |>
  st_transform(crs = st_crs(Area.sf)) |>
  filter(mag >= 0 & yr >= 2007) |>
  mutate(Length = len * 1609.34,
         Width = wid * .9144,
         maxEF = mag,
         Date = as.Date(date),
         Year = yr,
         Month = mo) |>
  select(Date, Year, Month, maxEF, Length, Width, slat, slon) |>
  st_crop(Area.sfc)
```

Mark all tornadoes that intersect urban areas.
```{r}
Intersects <- Urban2020.sf |>
  st_intersects(Torn.sf) |>
  unlist()

Torn.sf$row <- 1:nrow(Torn.sf)

Torn.sf <- Torn.sf |>
  mutate(Urban = row %in% Intersects)

tm_shape(Urban2020.sf) +
  tm_borders() +
  tm_shape(Torn.sf[Torn.sf$Urban, ]) +
  tm_lines(col = "red")
```

Group tornadoes by whether urban or not and examine EF rating statistics.
```{r}
Torn.sf |>
  st_drop_geometry() |>
  group_by(Urban) |>
  summarize(nT = n(),
            Avg = mean(maxEF),
            Median = median(maxEF),
            Min = min(maxEF),
            Max = max(maxEF),
            AvgL = mean(Length),
            MedianL = median(Length),
            AvgW = mean(Width),
            MedianW = median(Width))
```

On average the EF rating is lower for tornadoes in rural areas. Before jumping to conclusions we need to examine other factors like the fact that rural areas are much larger in the west.

Use a cumulative logistic model to quantify the effect rural areas have on the EF rating conditioning on path characteristics, location, and month.

Are tornadoes that affect urban areas longer? Yes. Also what about demographic data. Are damaging tornadoes in rich urban areas more likely to get a higher rating compared with damaging tornadoes in poor urban areas? This is an interesting question but is hard to answer given the gradient in wealth within large urban areas. Maybe using {tidycensus} https://twitter.com/mrworthington/status/1446910612471173121

Start by describing the ordered distribution of maximum EF ratings with intercepts. Begin with a histogram of maximum EF rating per tornado.
```{r}
#devtools::install_github("rmcelreath/rethinking")

( FreqByEF.df <- Torn.sf |>
  st_drop_geometry() |>
  group_by(Urban, maxEF) |>
  summarize(nT = n()) |>
    mutate(pr_k = case_when(Urban ~ nT / sum(nT),
                           !Urban ~ nT / sum(nT)),
           cum_pr_k = cumsum(pr_k),
           log_cum_odds = rethinking::logit(cum_pr_k),
           ys = cum_pr_k - pr_k,
           Names = case_when(Urban ~ "Urban",
                             !Urban ~ "Rural")) )

ggplot(FreqByEF.df, 
       mapping = aes(x = maxEF, y = pr_k)) + 
  geom_point() + 
  geom_segment(aes(xend = maxEF, yend = 0)) +
  facet_wrap(~ Names) +
  scale_y_continuous(limits = c(0, 1)) +
  labs(x = "Maximum EF Rating", y = "Percentage",
      title = "Tornadoes are more likely to get a higher damage rating in/near urban areas") +
  theme_minimal()

ggplot(FreqByEF.df,
       mapping = aes(x = maxEF, y = cum_pr_k, color = Names)) +
  geom_point() +
  geom_line() +
  scale_y_continuous(limits = c(0, 1)) +
  scale_x_continuous(minor_breaks = 0:5) +
    xlab("Maximum EF Rating") +
    ylab("Cumulative Proportion") +
  theme_minimal()

ggplot(FreqByEF.df,
       mapping = aes(x = maxEF, y = log_cum_odds, color = Names)) +
  geom_point() +
  geom_line() +
  scale_y_continuous(limits = c(NA, 10) ) +
  scale_x_continuous(limits = c(0, 4), minor_breaks = 0:4) +
  xlab("Maximum EF Rating") +
  ylab("Log-Cumulative-Odds") +
  theme_minimal()

ggplot(FreqByEF.df, 
       mapping = aes(x = maxEF, y = cum_pr_k)) +
  geom_segment(aes(x = maxEF, xend = maxEF, y = ys, yend = cum_pr_k), size = 1.3, color = "gray70") +
  geom_point() +
  geom_line() +
  facet_wrap(~ Names) +
  scale_y_continuous(limits = c(0, 1)) +
    xlab("Maximum EF Rating") +
    ylab("Cumulative Proportion") +
  theme_minimal()
```
### Figure: Relative frequency of tornadoes by maximum EF rating grouped by urban and rural occurrence. Only tornadoes occurring from Texas to North Dakota are considered. Log-cumulative odds of a tornado by maximum EF rating grouped by urban and rural occurrence.

Note that the cumulative logit for the highest EF rating is infinity. This is because log(1/(1 - 1)) = $\infty$. This is always the case so we do not need a parameter for it. We get it for free from the law of total probability. So for $K$ = 6 possible maximum EF ratings we only need $K$ - 1 = 5 intercepts.

Cumulative probability and ordered likelihood. The horizontal axis displays possible observable damage ratings, from 0 through 5. The vertical axis displays cumulative probability. The points show cumulative probability. These keep getting higher with each successive EF rating. The gray line segments show the discrete probability of each EF rating. These are the likelihoods that go into Bayes’ theorem.

In code form
$$
\begin{aligned} 
\hbox{R}_i &\sim \hbox{Ordered}(\mathbf{p}) \\ 
\hbox{logit}(p_k) &= \alpha_k \\
\alpha_k &\sim \hbox{Normal}(0, 10)
\end{aligned}
$$
The Ordered distribution is a categorical distribution that takes a vector $p = \{p_0, p_1, p_2, p_3, p_4\}$ of probabilities for each EF rating below the highest (EF5). Each response value $k$ in this vector is defined by its link to an intercept parameter ($\alpha_k$).

To include predictor variables, we define the log-cumulative-odds of each EF rating $k$ as a sum of its intercept $\alpha_k$ and a typical linear model. Suppose for  example we want to add a predictor $x$ to the model. We do this by defining a linear model $\phi_i = \beta x_i$. Then each cumulative logit becomes
$$
\begin{aligned}
\log \frac{\Pr(y_i \le k)}{1 - \Pr(y_i \le k)} &= \alpha_k - \phi_i \\
\phi_i &= \beta x_i
\end{aligned}
$$

The form ensures the correct ordering of the EF ratings while allowing for changes in the likelihood of each individual value as the predictor $x_i$ changes value. As the log-cumulative odds of every EF value ($k$) below the maximum decreases, the probability mass shifts upwards toward higher EF ratings.

$$
\phi_i = \beta_{Year}Year_i + \beta_L L_i + \beta_W W_i + \beta_{Urban}Urban_i + \beta_M M_i
$$

where Year_i indicates the year of tornado i and L_i and W_i indicate the length and width of damage path for tornado i. Month (M_i) is a random offset so the coefficient \beta_M is a vector of length 12. 


Use the {brms} package. Start by setting the family and the model formula. Get priors. 
```{r}
library(brms)
Torn.sf$maxEF1 <- Torn.sf$maxEF + 1 # can not use 0

family <- brms::cumulative(threshold = "flexible")
formula <- maxEF1 ~ 1

get_prior(formula, 
          data = Torn.sf, 
          family = family)

prior <- brm(formula = formula,
             data = Torn.sf,
             family = family,
             prior = set_prior("student_t(7, 0, 10)", class = "Intercept"),
             sample_prior = "only",
             seed = 9121)
prior_out <- predict(prior, probs = c(0, 1))
head(prior_out)

fit0 <- brm(formula = formula,
           data = Torn.sf,
           family = family,
           prior = set_prior("student_t(7, 0, 10)", class = "Intercept"),
           seed = 9121)
fixef(fit0)

fit0_out <- predict(fit0, probs = c(0, 1))
head(fit0_out)
```

Since there are a lot of tornadoes, the posterior for each intercept is quite precisely estimated, as we can see from the small standard deviations. To get cumulative probabilities back:
```{r}
rethinking::logistic(fixef(fit0))
```

These are the same (nearly) as the values in `cum_pr_k` that we computed above. But now we also have a posterior distribution around these values, and we’re ready to add predictor variables to the model.

Model with predictors. Start with some default priors (for example `"normal(0,5)"` for the `class = "b"`). Sample from the priors and check the predictive distribution of the response. Adjust the priors accordingly. https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations
```{r}
df <- Torn.sf |>
  st_drop_geometry() |>
  mutate(PathArea = Length * Width,
         PathAreaS = scale(PathArea))

family <- brms::cumulative(threshold = "flexible")
formula <- maxEF1 ~ Urban

get_prior(formula, 
          data = df, 
          family = family)

prior2 <- brm(formula = formula,
              data = df,
              family = family,
              prior = c(set_prior("normal(0, 1)", class = "b"),
                        set_prior("student_t(3, 0, 2.5)", class = "Intercept")),
              sample_prior = "only",
              control = list(max_treedepth = 15),
              seed = 9121)

prior_out2 <- predict(prior2, probs = c(0, 1))
```

With `normal(0, 5)` the probabilities are highest for the first and sixth categories. This u-shaped distribution is diminished by using `normal(0, 1)`.

Fit the model.
```{r}
formula1 <- maxEF1 ~ Urban
formula2 <- maxEF1 ~ Urban + PathAreaS
fit2 <- brm(formula = formula2,
            data = df,
            family = family,
            prior = c(set_prior("normal(0, 1)", class = "b"),
                     set_prior("student_t(3, 0, 2.5)", class = "Intercept")),
            control = list(max_treedepth = 15),
            seed = 78121)

fixef(fit2)

#save(fit2, file = "fit2.RData")
#load("fit1.RData")
fit1_out <- predict(fit1, probs = c(0, 1))
```

Extracting and visualizing tidy draws from {brms} models. https://cran.r-project.org/web/packages/tidybayes/vignettes/tidy-brms.html
```{r}
library(tidybayes)

get_variables(fit1)

fit2 |>
  spread_draws(b_LengthS, b_UrbanTRUE) |>
  head(20)

fit2 |>
  spread_draws(b_LengthS, b_UrbanTRUE) |>
  median_qi(b_LengthS, b_UrbanTRUE)

fit2 |>
  gather_draws(b_LengthS, b_UrbanTRUE) |>
  median_qi()
```

Add a plot. Fixed effects. Highest density interval.
```{r}
( fit2 |> 
  gather_draws(b_LengthS, b_UrbanTRUE) |>
  median_hdi(.width = c(.95, .66)) |>
  ggplot(aes(y = .variable, x = .value, xmin = .lower, xmax = .upper)) +
  geom_pointintervalh() +
  geom_vline(xintercept = 0, col = "gray70") +
  scale_y_discrete(labels = c("Path Length", "Urban?")) +
#  scale_x_continuous(limits = c(NA, NA), breaks = c(-.2, 0, .2)) +
  ylab("") + xlab("Coefficient Value") +
  theme_minimal() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) )
```

Conditional effect of rural on EF rating.
```{r}
gg <- conditional_effects(fit1, categorical = TRUE)
ggUrban <- gg[[1]] |>
  filter(cats__ != 1)
levels(ggUrban$cats__) <- c("EF0", "EF1", "EF2", "EF3", "EF4", "EF5")

( pfit2 <- ggplot(ggUrban, 
       mapping = aes(x = Urban, y = estimate__ * 100, label = cats__, color = Urban)) +
  geom_text() +
  scale_color_manual(values = c("#1FDE92", "#DE1F6B"), guide = "none") +
  scale_y_log10(limits = c(.01, 100), labels = c(".01%", ".1%", "1%", "10%", "100%"), breaks = c(.01, .1, 1, 10, 100)) +
#  scale_y_log10() +
  scale_x_discrete(labels = c("Rural", "Urban")) + 
  labs(caption = "Chance a tornado causes EF-level damage given location. Data source: NOAA",
       title = "Tornadoes impacting rural areas are less likely to get a higher\ndamage rating relative to those impacting urban areas",
       x = "", y = "") +
  theme_minimal() )
```







Compute the distance between the tornado and the nearest urban polygon.
```{r}
distFromUrban <- numeric()
for(i in seq_len(nrow(Torn.sf))){
  distFromUrban[i] <- min(st_distance(Torn.sf[i, ], Urban2020.sf))
}
```

Get census data from these CBSAs. https://walker-data.com/tidycensus/articles/spatial-data.html
```{r}
options(tigris_use_cache = TRUE)

( Augusta <- get_decennial(geography = "tract",
                           variables = "P001001",
                           year = 2000,
                           state = "GA", 
                           county = "Richmond", 
                           geometry = TRUE,
                           summary_var = "P001001") )
```

